      # 核心步骤：调用 Dify 并获取结果 (异步轮询) - 优化版
      - name: Call Dify Workflow Asynchronously and Poll for Result
        id: dify_call_async
        run: |
          # --- 步骤 1: 触发工作流并获取 task_id (使用流式读取，防止启动超时) ---
          echo "Triggering Dify workflow and waiting for task_id..."
          
          # 使用 curl -N (或 --no-buffer) 来处理流式响应，防止因 Dify 启动慢于 60s 而导致网关超时
          # 使用 `timeout` 命令确保此步骤不会无限期挂起，例如最多等待 3 分钟来获取 task_id
          task_id=""
          timeout 180s curl -sS -N -X POST "${{ secrets.DIFY_WORKFLOW_URL }}" \
            -H "Authorization: Bearer ${{ secrets.DIFY_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{
              "inputs": {},
              "response_mode": "streaming",
              "user": "github-actions-async-job"
            }' | while read -r line; do
              # 我们只关心包含 task_id 的第一条 'workflow_started' 事件
              if [[ $line == data:* ]]; then
                # 提取 JSON 部分
                json_data=$(echo "$line" | sed 's/^data: //')
                
                # 检查是否是 workflow_started 事件
                event=$(echo "$json_data" | jq -r '.event')
                if [[ "$event" == "workflow_started" ]]; then
                  task_id=$(echo "$json_data" | jq -r '.task_id')
                  echo "Successfully received task_id: $task_id"
                  # 成功获取 task_id 后，杀掉仍在运行的 curl 进程并退出循环
                  # 因为我们只需要 task_id，不需要后续的流式结果
                  pkill -P $$ curl # pkill curl that is a child of the current shell process
                  break
                fi
              fi
            done

          # 检查是否成功获取 task_id
          if [ -z "$task_id" ]; then
            echo "::error::Failed to get task_id from Dify stream after 180 seconds."
            exit 1
          fi

          # --- 步骤 2: 轮询任务状态 (这部分逻辑保持不变) ---
          status_url="https://api.dify.ai/v1/tasks/${task_id}/result" # 如果是自部署，请修改域名
          
          max_retries=60 # 增加轮询次数，总时长 60 * 10s = 600s = 10分钟
          sleep_interval=10

          for (( i=1; i<=max_retries; i++ )); do
            echo "Polling attempt #$i for task $task_id..."
            status_response=$(curl -sS -X GET "$status_url" \
              -H "Authorization: Bearer ${{ secrets.DIFY_API_KEY }}")

            status=$(echo "$status_response" | jq -r '.status')
            echo "Current task status: $status"

            if [ "$status" == "succeeded" ]; then
              echo "Task succeeded!"
              # !! 重要 !!: 同样需要根据你的输出变量名修改 '.outputs.text'
              final_result=$(echo "$status_response" | jq -r '.outputs.text')
              
              # 设置输出并退出循环
              echo "result<<EOF" >> $GITHUB_OUTPUT
              echo "$final_result" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
              exit 0
            
            elif [ "$status" == "failed" ] || [ "$status" == "stopped" ]; then
              echo "::error::Task failed or was stopped. Full response:"
              echo "$status_response"
              exit 1
            fi

            sleep $sleep_interval
          done

          echo "::error::Polling timed out after $(($max_retries * $sleep_interval)) seconds."
          exit 1
